<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Small World Network Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=JetBrains+Mono:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
            overflow: hidden; /* Prevent scrolling, canvas takes full space */
        }

        .mono {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Custom Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #38bdf8;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #334155;
            border-radius: 2px;
        }
        input[type=range]:focus {
            outline: none;
        }
        
        /* Floating Control Panel */
        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
    </style>
</head>
<body class="w-screen h-screen relative">

    <!-- Visualization Canvas -->
    <canvas id="networkCanvas"></canvas>

    <!-- Overlay UI -->
    <div class="absolute top-0 left-0 w-full h-full pointer-events-none flex flex-col md:flex-row p-4 md:p-6 gap-4">
        
        <!-- Controls Sidebar -->
        <div class="glass-panel rounded-xl p-6 w-full md:w-80 pointer-events-auto flex flex-col gap-6 h-fit max-h-full overflow-y-auto z-10 shrink-0">
            <div>
                <h1 class="text-xl font-bold text-sky-400 mb-1">Small World Demo</h1>
                <p class="text-xs text-slate-400">Watts-Strogatz Model Visualization</p>
            </div>

            <!-- Stats -->
            <div class="grid grid-cols-2 gap-3 p-3 bg-slate-800/50 rounded-lg border border-slate-700/50">
                <div>
                    <div class="text-[10px] uppercase tracking-wider text-slate-400 font-semibold">Avg Path Len</div>
                    <div class="text-xl font-bold text-emerald-400 mono" id="stat-avg-path">--</div>
                </div>
                <div>
                    <div class="text-[10px] uppercase tracking-wider text-slate-400 font-semibold">Separation</div>
                    <div class="text-xl font-bold text-pink-400 mono" id="stat-separation">--</div>
                </div>
            </div>

            <!-- Inputs -->
            <div class="space-y-5">
                <!-- Nodes (N) -->
                <div class="space-y-2">
                    <div class="flex justify-between items-center text-sm">
                        <label class="text-slate-300">Nodes (N)</label>
                        <span class="mono text-sky-300" id="val-n">200</span>
                    </div>
                    <!-- Increased max to 5000. 10^6 is too heavy for standard Canvas 2D without WebGL/Workers -->
                    <input type="range" id="input-n" min="20" max="5000" value="200" step="10">
                    <p class="text-[10px] text-slate-500">Total number of entities in the graph.</p>
                </div>

                <!-- Neighbors (K) -->
                <div class="space-y-2">
                    <div class="flex justify-between items-center text-sm">
                        <label class="text-slate-300">Neighbors (K)</label>
                        <span class="mono text-sky-300" id="val-k">4</span>
                    </div>
                    <input type="range" id="input-k" min="2" max="20" value="4" step="2">
                    <p class="text-[10px] text-slate-500">Initial connections per node (must be even).</p>
                </div>

                <!-- Rewire Prob (p) -->
                <div class="space-y-2">
                    <div class="flex justify-between items-center text-sm">
                        <label class="text-slate-300">Rewire Prob (p)</label>
                        <span class="mono text-sky-300" id="val-p">0.10</span>
                    </div>
                    <input type="range" id="input-p" min="0" max="1" value="0.1" step="0.01">
                    <div class="flex justify-between text-[10px] text-slate-500">
                        <span>Regular</span>
                        <span>Small World</span>
                        <span>Random</span>
                    </div>
                </div>
            </div>

            <!-- Actions -->
            <div class="pt-2 space-y-3">
                <button id="btn-generate" class="w-full py-3 bg-sky-600 hover:bg-sky-500 text-white rounded-lg font-semibold shadow-lg shadow-sky-900/50 transition-all active:scale-95 flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></svg>
                    Regenerate Network
                </button>
                <button id="btn-find-path" class="w-full py-2 bg-slate-700 hover:bg-slate-600 text-slate-200 rounded-lg text-sm font-medium border border-slate-600 transition-all active:scale-95">
                    Find New Path
                </button>
            </div>
            
            <div class="text-[10px] text-slate-500 leading-relaxed border-t border-slate-700/50 pt-4">
                <strong>How it works:</strong> The Watts-Strogatz model starts with a regular ring. By rewiring a few edges randomly (increasing <em>p</em>), shortcuts are created. These shortcuts drastically reduce the average path length while maintaining clustering, creating a "Small World."
            </div>
        </div>
    </div>

    <script>
        /**
         * Simulation Logic & Visualization
         */
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');
        
        // State
        let nodes = [];
        let edges = []; // Adjacency list: Map<nodeId, Set<nodeId>>
        let path = []; // Current highlighted path
        let params = {
            N: 200, // Nodes
            K: 4,  // Mean degree (even integer)
            p: 0.1 // Rewiring probability
        };

        // UI Elements
        const ui = {
            n: document.getElementById('input-n'),
            k: document.getElementById('input-k'),
            p: document.getElementById('input-p'),
            valN: document.getElementById('val-n'),
            valK: document.getElementById('val-k'),
            valP: document.getElementById('val-p'),
            btnGen: document.getElementById('btn-generate'),
            btnPath: document.getElementById('btn-find-path'),
            statAvg: document.getElementById('stat-avg-path'),
            statSep: document.getElementById('stat-separation')
        };

        // Resize Canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Regenerate graph to fix positions relative to sidebar
            generateGraph();
        }
        window.addEventListener('resize', resize);

        // --- Core Algorithm: Watts-Strogatz ---

        function generateGraph() {
            nodes = [];
            edges = new Map();
            path = [];

            const { N, K, p } = params;

            // Layout Logic: Avoid sidebar overlap
            // Sidebar is approx 320px + 48px padding (approx 370px) on Desktop
            const isDesktop = window.innerWidth >= 768;
            const sidebarOffset = isDesktop ? 370 : 0;
            const availableWidth = canvas.width - sidebarOffset;
            
            // Center in the *available* space
            const centerX = sidebarOffset + (availableWidth / 2);
            // On mobile, just center vertically, maybe push down slightly if needed
            const centerY = canvas.height / 2;
            
            // Adjust radius to fit
            const radius = Math.min(availableWidth, canvas.height) * 0.40;

            // 1. Create Nodes in a Circle
            for (let i = 0; i < N; i++) {
                const angle = (i / N) * 2 * Math.PI - Math.PI / 2;
                nodes.push({
                    id: i,
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius,
                    angle: angle
                });
                edges.set(i, new Set());
            }

            // 2. Create Regular Ring Lattice
            // Connect each node to K/2 neighbors on each side
            let rawEdges = []; // Store as [source, target] for rewiring phase

            for (let i = 0; i < N; i++) {
                for (let j = 1; j <= K / 2; j++) {
                    const target = (i + j) % N;
                    rawEdges.push({ source: i, target: target, originalTarget: target });
                    addEdge(i, target); 
                }
            }

            // 3. Rewire Edges
            // Clear map to rebuild based on wiring
            edges = new Map();
            nodes.forEach(n => edges.set(n.id, new Set()));

            rawEdges.forEach(edge => {
                let u = edge.source;
                let v = edge.target;

                if (Math.random() < p) {
                    // Rewire logic
                    let candidates = [];
                    
                    // Optimization: For very large N, picking a random valid node is expensive if we check duplicates strictly.
                    // Simplified random pick:
                    const rand = Math.floor(Math.random() * N);
                    if (rand !== u && rand !== v) {
                        v = rand;
                    }
                }
                addEdge(u, v);
            });

            // Calculate Stats (Skip if N is too huge to prevent UI freeze)
            if (params.N <= 3000) {
                calculateStats();
            } else {
                ui.statAvg.innerText = "> 3k";
                ui.statSep.innerText = "--";
            }
            
            // Find a random path to demonstrate
            findRandomPath();
            
            draw();
        }

        function addEdge(u, v) {
            if (u === v) return;
            if (!edges.has(u)) edges.set(u, new Set());
            if (!edges.has(v)) edges.set(v, new Set());
            
            edges.get(u).add(v);
            edges.get(v).add(u);
        }

        // --- Pathfinding (BFS) ---

        function getShortestPath(startId, endId) {
            if (startId === endId) return [startId];
            
            let queue = [startId];
            let visited = new Set([startId]);
            let parent = new Map();

            // Safety break for huge graphs
            let iterations = 0;
            const maxIter = 50000;

            while (queue.length > 0) {
                iterations++;
                if (iterations > maxIter) return null;

                let current = queue.shift();

                if (current === endId) {
                    // Reconstruct path
                    let pathArr = [];
                    let curr = endId;
                    while (curr !== undefined) {
                        pathArr.unshift(curr);
                        curr = parent.get(curr);
                    }
                    return pathArr;
                }

                const neighbors = edges.get(current);
                if (neighbors) {
                    for (let neighbor of neighbors) {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            parent.set(neighbor, current);
                            queue.push(neighbor);
                        }
                    }
                }
            }
            return null; // No path found
        }

        function findRandomPath() {
            const start = Math.floor(Math.random() * params.N);
            // Pick an end node that is somewhat distant in index to make it interesting
            let end = (start + Math.floor(params.N / 2)) % params.N; 
            
            // Run BFS
            // If N is massive, this might take a moment, but usually BFS is fast enough even for 10k
            path = getShortestPath(start, end);
            
            if (path) {
                ui.statSep.innerText = (path.length - 1).toString();
            } else {
                ui.statSep.innerText = "Inf";
            }
            draw();
        }

        // --- Statistics ---

        function calculateStats() {
            let totalPathLen = 0;
            let pairs = 0;
            const N = params.N;

            // Adaptive Sampling
            let sampleSize = 50; // Default
            if (N > 500) sampleSize = 20;
            if (N > 1000) sampleSize = 5; // Very sparse sampling for large graphs
            
            const sources = Array.from({length: sampleSize}, () => Math.floor(Math.random() * N));

            for (let src of sources) {
                let queue = [[src, 0]]; 
                let visited = new Set([src]);
                
                // Safety limiter
                let ops = 0;

                while(queue.length > 0) {
                    ops++;
                    if(ops > 50000) break; // Don't freeze

                    let [curr, dist] = queue.shift();
                    
                    if (curr !== src) {
                        totalPathLen += dist;
                        pairs++;
                    }

                    const neighbors = edges.get(curr);
                    if(neighbors) {
                        for(let n of neighbors) {
                            if(!visited.has(n)) {
                                visited.add(n);
                                queue.push([n, dist + 1]);
                            }
                        }
                    }
                }
            }

            if (pairs > 0) {
                const avg = totalPathLen / pairs;
                ui.statAvg.innerText = avg.toFixed(2);
            } else {
                ui.statAvg.innerText = "~";
            }
        }

        // --- Rendering ---

        function draw() {
            // Clear
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Optimization for high N
            const highPerformanceMode = params.N > 1500;

            // Draw Edges
            // If high performance, make lines thinner and more transparent
            ctx.lineWidth = highPerformanceMode ? 0.5 : 1;
            
            let drawnEdges = new Set();

            nodes.forEach(node => {
                const neighbors = edges.get(node.id);
                if (!neighbors) return;
                
                neighbors.forEach(neighborId => {
                    // Optimization: In very dense graphs, only draw a subset of edges? 
                    // Or just let canvas handle it (Canvas handles 20k lines ok on desktop)
                    
                    const pairId = [Math.min(node.id, neighborId), Math.max(node.id, neighborId)].join('-');
                    if (drawnEdges.has(pairId)) return;
                    drawnEdges.add(pairId);

                    const neighbor = nodes[neighborId];
                    
                    const dist = Math.abs(node.id - neighborId);
                    const ringDist = Math.min(dist, params.N - dist);
                    const isShortcut = ringDist > params.K / 2;

                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(neighbor.x, neighbor.y);
                    
                    if (isShortcut) {
                        // Cyan for shortcuts
                        ctx.strokeStyle = `rgba(56, 189, 248, ${highPerformanceMode ? 0.3 : Math.max(0.1, 0.4 - (params.N/500))})`; 
                    } else {
                        // Slate for ring lattice
                        ctx.strokeStyle = `rgba(148, 163, 184, ${highPerformanceMode ? 0.1 : Math.max(0.05, 0.2 - (params.N/500))})`; 
                    }
                    ctx.stroke();
                });
            });

            // Draw Path Highlighting
            if (path && path.length > 1) {
                ctx.lineWidth = highPerformanceMode ? 2 : 3;
                ctx.shadowBlur = highPerformanceMode ? 0 : 10;
                ctx.shadowColor = '#f472b6'; 
                ctx.strokeStyle = '#f472b6';
                ctx.beginPath();
                
                const startNode = nodes[path[0]];
                ctx.moveTo(startNode.x, startNode.y);

                for (let i = 1; i < path.length; i++) {
                    const nextNode = nodes[path[i]];
                    ctx.lineTo(nextNode.x, nextNode.y);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.lineWidth = 1;
            }

            // Draw Nodes
            // Optimization: If N is huge, don't draw nodes, or draw 1px rectangles
            if (params.N <= 3000) {
                nodes.forEach(node => {
                    const inPath = path && path.includes(node.id);
                    const isEndpoints = path && (node.id === path[0] || node.id === path[path.length - 1]);

                    // Skip drawing regular nodes if high performance mode to save FPS
                    if (highPerformanceMode && !inPath) return;

                    ctx.beginPath();
                    const r = isEndpoints ? 6 : (inPath ? 4 : Math.max(1, 5 - (params.N / 150)));
                    
                    ctx.arc(node.x, node.y, r, 0, Math.PI * 2);
                    
                    if (isEndpoints) {
                        ctx.fillStyle = '#f472b6'; 
                        ctx.shadowBlur = 15;
                    } else if (inPath) {
                        ctx.fillStyle = '#f472b6';
                        ctx.shadowBlur = 0;
                    } else {
                        ctx.fillStyle = '#38bdf8'; 
                        ctx.shadowBlur = 0;
                    }
                    
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });
            } else {
                 // Ultra high mode: Just draw endpoints
                if (path && path.length > 0) {
                     // Draw Start
                     const start = nodes[path[0]];
                     ctx.beginPath(); ctx.arc(start.x, start.y, 6, 0, Math.PI*2); 
                     ctx.fillStyle = '#f472b6'; ctx.fill();
                     
                     // Draw End
                     const end = nodes[path[path.length-1]];
                     ctx.beginPath(); ctx.arc(end.x, end.y, 6, 0, Math.PI*2); 
                     ctx.fillStyle = '#f472b6'; ctx.fill();
                }
            }
        }

        // --- Interaction Listeners ---

        function updateParams() {
            params.N = parseInt(ui.n.value);
            params.K = parseInt(ui.k.value);
            params.p = parseFloat(ui.p.value);

            // Constraint: K < N
            if (params.K >= params.N) {
                params.K = params.N - 1;
                if (params.K % 2 !== 0) params.K -= 1;
                ui.k.value = params.K;
            }

            ui.valN.innerText = params.N;
            ui.valK.innerText = params.K;
            ui.valP.innerText = params.p.toFixed(2);
            
            generateGraph();
        }

        ui.n.addEventListener('input', updateParams);
        ui.k.addEventListener('input', updateParams);
        ui.p.addEventListener('input', updateParams);
        
        ui.btnGen.addEventListener('click', generateGraph);
        ui.btnPath.addEventListener('click', findRandomPath);

        // Init
        // Use timeout to ensure window size is stable
        setTimeout(() => {
            resize();
            generateGraph();
        }, 100);

    </script>
</body>
</html>
