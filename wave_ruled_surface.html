<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wave Ruled Surface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #fff;
        }
        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            text-align: center;
        }
        .subtitle {
            color: #888;
            margin-bottom: 20px;
            text-align: center;
            font-size: 0.95rem;
        }
        #canvas-container {
            background: #0f0f1a;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        .controls {
            margin-top: 20px;
            background: rgba(255,255,255,0.1);
            padding: 20px 30px;
            border-radius: 12px;
            width: 100%;
            max-width: 550px;
        }
        .slider-container {
            margin-bottom: 15px;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        .slider-value {
            color: #e07b53;
            font-weight: bold;
        }
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #e07b53;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(224,123,83,0.5);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #e07b53;
            cursor: pointer;
            border: none;
        }
        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-primary {
            background: #e07b53;
            color: #1a1a2e;
            font-weight: bold;
        }
        .btn-primary:hover {
            background: #c96a45;
            transform: translateY(-2px);
        }
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
        }
        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }
        .checkbox-row {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .checkbox-item input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            font-size: 0.85rem;
            line-height: 1.6;
            max-width: 550px;
        }
        .info h3 {
            color: #e07b53;
            margin-bottom: 10px;
        }
        .color-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 5px;
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <h1>Wave Ruled Surface</h1>
    <p class="subtitle">Straight rods connecting two sinusoidal curves — Drag to rotate</p>
    
    <div id="canvas-container">
        <canvas id="canvas" width="600" height="450"></canvas>
    </div>
    
    <div class="controls">
        <div class="slider-container">
            <div class="slider-label">
                <span>Phase Shift (front vs back)</span>
                <span class="slider-value" id="phase-value">0°</span>
            </div>
            <input type="range" id="phase-slider" min="-180" max="180" value="0" step="1">
        </div>
        
        <div class="slider-container">
            <div class="slider-label">
                <span>Wave Amplitude</span>
                <span class="slider-value" id="amplitude-value">60</span>
            </div>
            <input type="range" id="amplitude-slider" min="0" max="120" value="60" step="5">
        </div>
        
        <div class="slider-container">
            <div class="slider-label">
                <span>Wave Frequency</span>
                <span class="slider-value" id="frequency-value">3</span>
            </div>
            <input type="range" id="frequency-slider" min="0" max="6" value="3" step="0.5">
        </div>
        
        <div class="slider-container">
            <div class="slider-label">
                <span>Number of Rods</span>
                <span class="slider-value" id="rods-value">50</span>
            </div>
            <input type="range" id="rods-slider" min="10" max="100" value="50" step="1">
        </div>
        
        <div class="checkbox-row">
            <label class="checkbox-item">
                <input type="checkbox" id="show-curves" checked>
                <span><span class="color-indicator" style="background:#3498db"></span>Edge Curves</span>
            </label>
            <label class="checkbox-item">
                <input type="checkbox" id="show-frame" checked>
                <span><span class="color-indicator" style="background:#666"></span>Frame</span>
            </label>
            <label class="checkbox-item">
                <input type="checkbox" id="animate-wave">
                <span>Animate Wave</span>
            </label>
        </div>
        
        <div class="button-row">
            <button class="btn-primary" id="animate-btn">▶ Auto Rotate</button>
            <button class="btn-secondary" id="reset-btn">Reset View</button>
        </div>
    </div>
    
    <div class="info">
        <h3>Mathematical Description</h3>
        <p>
            This <strong>wave ruled surface</strong> is formed by straight lines (rulings) 
            connecting two sinusoidal curves:
        </p>
        <p style="margin-top:8px; font-family: serif; font-style: italic;">
            Front edge: z = A·sin(ωx)<br>
            Back edge: z = A·sin(ωx + φ)
        </p>
        <p style="margin-top:8px;">
            When the phase shift φ = 0, all rods are horizontal. As φ increases, 
            the rods tilt, creating a twisted wave surface. This is a classic example 
            of a ruled surface used in architecture and design.
        </p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Controls
        const phaseSlider = document.getElementById('phase-slider');
        const amplitudeSlider = document.getElementById('amplitude-slider');
        const frequencySlider = document.getElementById('frequency-slider');
        const rodsSlider = document.getElementById('rods-slider');
        const phaseValue = document.getElementById('phase-value');
        const amplitudeValue = document.getElementById('amplitude-value');
        const frequencyValue = document.getElementById('frequency-value');
        const rodsValue = document.getElementById('rods-value');
        const animateBtn = document.getElementById('animate-btn');
        const resetBtn = document.getElementById('reset-btn');
        const showCurves = document.getElementById('show-curves');
        const showFrame = document.getElementById('show-frame');
        const animateWave = document.getElementById('animate-wave');

        // 3D parameters
        let rotationX = 0.4;
        let rotationY = -0.3;
        let phase = 0;           // Phase shift in degrees
        let amplitude = 60;      // Wave amplitude
        let frequency = 3;       // Number of wave cycles
        let numRods = 50;
        
        const width = 300;       // Length of the surface (x direction)
        const depth = 120;       // Depth of the surface (y direction)
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const scale = 0.9;

        // Animation state
        let isRotating = false;
        let animationId = null;
        let waveTime = 0;

        // Mouse drag state
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Project 3D point to 2D with perspective
        function project(x, y, z) {
            // Center the surface
            x -= width / 2;
            
            // Rotate around Y axis
            const cosY = Math.cos(rotationY);
            const sinY = Math.sin(rotationY);
            let x1 = x * cosY - y * sinY;
            let y1 = x * sinY + y * cosY;
            
            // Rotate around X axis
            const cosX = Math.cos(rotationX);
            const sinX = Math.sin(rotationX);
            let y2 = z * cosX - y1 * sinX;
            let z2 = z * sinX + y1 * cosX;
            
            // Perspective projection
            const perspective = 800;
            const factor = perspective / (perspective + z2);
            
            return {
                x: centerX + x1 * factor * scale,
                y: centerY - y2 * factor * scale,
                z: z2
            };
        }

        // Generate points along a sine wave
        function getSineWavePoints(yPos, phaseOffset, nPoints = 100) {
            const points = [];
            const phaseRad = phaseOffset * Math.PI / 180;
            
            for (let i = 0; i <= nPoints; i++) {
                const t = i / nPoints;
                const x = t * width;
                const z = amplitude * Math.sin(frequency * 2 * Math.PI * t + phaseRad + waveTime);
                points.push({ x, y: yPos, z });
            }
            return points;
        }

        // Generate the ruling lines (rods)
        function getRulingLines(nRods) {
            const lines = [];
            const phaseRad = phase * Math.PI / 180;
            
            for (let i = 0; i <= nRods; i++) {
                const t = i / nRods;
                const x = t * width;
                
                // Front edge point (y = 0)
                const z_front = amplitude * Math.sin(frequency * 2 * Math.PI * t + waveTime);
                
                // Back edge point (y = depth) with phase shift
                const z_back = amplitude * Math.sin(frequency * 2 * Math.PI * t + phaseRad + waveTime);
                
                lines.push({
                    front: { x, y: 0, z: z_front },
                    back: { x, y: depth, z: z_back }
                });
            }
            return lines;
        }

        // Draw the scene
        function draw() {
            ctx.fillStyle = '#0f0f1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const lines = getRulingLines(numRods);
            
            // Collect all drawable elements with depth
            const elements = [];
            
            // Frame (rectangular boundary)
            if (showFrame.checked) {
                const frameCorners = [
                    { x: 0, y: 0, z: 0 },
                    { x: width, y: 0, z: 0 },
                    { x: width, y: depth, z: 0 },
                    { x: 0, y: depth, z: 0 }
                ];
                
                for (let i = 0; i < 4; i++) {
                    const p1 = frameCorners[i];
                    const p2 = frameCorners[(i + 1) % 4];
                    const proj1 = project(p1.x, p1.y, p1.z);
                    const proj2 = project(p2.x, p2.y, p2.z);
                    elements.push({
                        type: 'frame',
                        p1: proj1,
                        p2: proj2,
                        z: (proj1.z + proj2.z) / 2
                    });
                }
            }
            
            // Edge curves
            if (showCurves.checked) {
                const frontCurve = getSineWavePoints(0, 0);
                const backCurve = getSineWavePoints(depth, phase);
                
                // Add front curve segments
                for (let i = 0; i < frontCurve.length - 1; i++) {
                    const proj1 = project(frontCurve[i].x, frontCurve[i].y, frontCurve[i].z);
                    const proj2 = project(frontCurve[i+1].x, frontCurve[i+1].y, frontCurve[i+1].z);
                    elements.push({
                        type: 'curve',
                        p1: proj1,
                        p2: proj2,
                        z: (proj1.z + proj2.z) / 2,
                        edge: 'front'
                    });
                }
                
                // Add back curve segments
                for (let i = 0; i < backCurve.length - 1; i++) {
                    const proj1 = project(backCurve[i].x, backCurve[i].y, backCurve[i].z);
                    const proj2 = project(backCurve[i+1].x, backCurve[i+1].y, backCurve[i+1].z);
                    elements.push({
                        type: 'curve',
                        p1: proj1,
                        p2: proj2,
                        z: (proj1.z + proj2.z) / 2,
                        edge: 'back'
                    });
                }
            }
            
            // Ruling lines (rods)
            lines.forEach(line => {
                const proj1 = project(line.front.x, line.front.y, line.front.z);
                const proj2 = project(line.back.x, line.back.y, line.back.z);
                elements.push({
                    type: 'rod',
                    p1: proj1,
                    p2: proj2,
                    z: (proj1.z + proj2.z) / 2
                });
            });
            
            // Sort by depth (far to near)
            elements.sort((a, b) => b.z - a.z);
            
            // Draw elements
            elements.forEach(elem => {
                ctx.beginPath();
                ctx.moveTo(elem.p1.x, elem.p1.y);
                ctx.lineTo(elem.p2.x, elem.p2.y);
                
                if (elem.type === 'frame') {
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 2;
                } else if (elem.type === 'curve') {
                    ctx.strokeStyle = elem.edge === 'front' ? '#3498db' : '#2ecc71';
                    ctx.lineWidth = 2.5;
                } else if (elem.type === 'rod') {
                    // Depth-based shading for rods
                    const brightness = Math.max(0.3, Math.min(1, 1 - elem.z / 300));
                    // Gradient from brown to copper color like the real model
                    const r = Math.floor(180 + 40 * brightness);
                    const g = Math.floor(80 + 30 * brightness);
                    const b = Math.floor(60 + 20 * brightness);
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${brightness})`;
                    ctx.lineWidth = 2.5;
                }
                ctx.stroke();
            });
            
            // Draw axis indicator
            drawAxisIndicator();
        }

        function drawAxisIndicator() {
            const axisSize = 30;
            const ox = 50;
            const oy = canvas.height - 50;
            
            const axes = [
                { dir: [1, 0, 0], color: '#e74c3c', label: 'X' },
                { dir: [0, 1, 0], color: '#2ecc71', label: 'Y' },
                { dir: [0, 0, 1], color: '#3498db', label: 'Z' }
            ];
            
            axes.forEach(axis => {
                const p = project(width/2 + axis.dir[0] * axisSize, axis.dir[1] * axisSize, axis.dir[2] * axisSize);
                const origin = project(width/2, 0, 0);
                const dx = p.x - origin.x;
                const dy = p.y - origin.y;
                
                ctx.beginPath();
                ctx.moveTo(ox, oy);
                ctx.lineTo(ox + dx * 0.8, oy + dy * 0.8);
                ctx.strokeStyle = axis.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = axis.color;
                ctx.font = '12px sans-serif';
                ctx.fillText(axis.label, ox + dx * 0.95, oy + dy * 0.95);
            });
        }

        // Animation loop
        function animate() {
            if (isRotating) {
                rotationY += 0.008;
            }
            
            if (animateWave.checked) {
                waveTime += 0.05;
            }
            
            if (isRotating || animateWave.checked) {
                draw();
                animationId = requestAnimationFrame(animate);
            }
        }

        function startAnimation() {
            if (!animationId) {
                animate();
            }
        }

        // Event listeners
        phaseSlider.addEventListener('input', () => {
            phase = parseFloat(phaseSlider.value);
            phaseValue.textContent = `${phase}°`;
            draw();
        });

        amplitudeSlider.addEventListener('input', () => {
            amplitude = parseFloat(amplitudeSlider.value);
            amplitudeValue.textContent = amplitude;
            draw();
        });

        frequencySlider.addEventListener('input', () => {
            frequency = parseFloat(frequencySlider.value);
            frequencyValue.textContent = frequency;
            draw();
        });

        rodsSlider.addEventListener('input', () => {
            numRods = parseInt(rodsSlider.value);
            rodsValue.textContent = numRods;
            draw();
        });

        showCurves.addEventListener('change', draw);
        showFrame.addEventListener('change', draw);
        
        animateWave.addEventListener('change', () => {
            if (animateWave.checked) {
                startAnimation();
            } else if (!isRotating) {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
        });

        animateBtn.addEventListener('click', () => {
            isRotating = !isRotating;
            if (isRotating) {
                animateBtn.textContent = '⏸ Stop Rotation';
                startAnimation();
            } else {
                animateBtn.textContent = '▶ Auto Rotate';
                if (!animateWave.checked && animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
        });

        resetBtn.addEventListener('click', () => {
            rotationX = 0.4;
            rotationY = -0.3;
            phase = 0;
            amplitude = 60;
            frequency = 3;
            numRods = 50;
            waveTime = 0;
            
            phaseSlider.value = 0;
            amplitudeSlider.value = 60;
            frequencySlider.value = 3;
            rodsSlider.value = 50;
            
            phaseValue.textContent = '0°';
            amplitudeValue.textContent = '60';
            frequencyValue.textContent = '3';
            rodsValue.textContent = '50';
            
            draw();
        });

        // Mouse drag rotation
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;
            
            rotationY += dx * 0.01;
            rotationX += dy * 0.01;
            rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            draw();
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.style.cursor = 'grab';

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
            lastMouseX = e.touches[0].clientX;
            lastMouseY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDragging) return;
            
            const dx = e.touches[0].clientX - lastMouseX;
            const dy = e.touches[0].clientY - lastMouseY;
            
            rotationY += dx * 0.01;
            rotationX += dy * 0.01;
            rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX));
            
            lastMouseX = e.touches[0].clientX;
            lastMouseY = e.touches[0].clientY;
            
            draw();
        });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });

        // Initial draw
        draw();
    </script>
</body>
</html>
