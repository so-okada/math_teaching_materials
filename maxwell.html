<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maxwell's 2D FDTD Simulator</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --panel-color: #1e293b;
            --text-color: #e2e8f0;
            --accent-color: #38bdf8;
            --danger-color: #ef4444;
            --success-color: #22c55e;
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
        }

        h1 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
            letter-spacing: -0.025em;
        }

        .container {
            position: relative;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #334155;
        }

        canvas {
            display: block;
            background-color: #000;
            cursor: crosshair;
            touch-action: none;
        }

        .controls {
            background-color: var(--panel-color);
            padding: 1rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            border-top: 1px solid #334155;
        }

        button {
            background-color: #475569; /* Default inactive */
            color: #e2e8f0;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        button:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }

        button.active {
            background-color: var(--accent-color);
            color: #0f172a;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.3);
        }

        button.danger {
            background-color: var(--danger-color);
            color: white;
        }
        
        button.success {
            background-color: var(--success-color);
            color: white;
        }

        .mode-group {
            display: flex;
            gap: 0.5rem;
            padding: 0.25rem;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        input[type="range"] {
            accent-color: var(--accent-color);
            width: 100px;
        }

        .overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.8rem;
            pointer-events: none;
            text-shadow: 0 1px 2px black;
        }
        
        @media (max-width: 600px) {
            canvas { width: 100%; height: auto; }
            .controls { flex-direction: column; align-items: stretch; }
            .slider-group { justify-content: space-between; }
        }
    </style>
</head>
<body>

    <h1>Maxwell's Equations Solver (FDTD)</h1>

    <div class="container">
        <canvas id="simCanvas"></canvas>
        <div class="overlay" id="statusText">Ez Field | Mode: Draw Walls</div>
        
        <div class="controls">
            <button id="btnPause" class="success">Pause</button>
            
            <div class="mode-group">
                <button id="btnModeWall" class="active">Draw Wall</button>
                <button id="btnModeSource">Add Source</button>
            </div>

            <button id="btnClear" class="danger">Clear Walls</button>
            <button id="btnClearSources" class="danger">Clear Sources</button>
            <button id="btnReset" class="danger">Reset All</button>
            
            <div class="slider-group">
                <label for="freq">Freq</label>
                <input type="range" id="freq" min="1" max="20" value="7">
            </div>

            <div class="slider-group">
                <label for="speed">Speed</label>
                <input type="range" id="speed" min="1" max="5" value="1">
            </div>
        </div>
    </div>

<script>
    /**
     * MAXWELL'S EQUATIONS FDTD SIMULATION
     */

    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    
    // Grid Setup
    const width = 200;
    const height = 150;
    const scale = 3; 

    canvas.width = width * scale;
    canvas.height = height * scale;

    // Physics Arrays
    const size = width * height;
    const Ez = new Float32Array(size);
    const Hx = new Float32Array(size);
    const Hy = new Float32Array(size);
    const Material = new Uint8Array(size); // 0=Air, 1=Metal

    // Rendering Buffer
    const imgData = ctx.createImageData(canvas.width, canvas.height);
    const pixels = new Uint32Array(imgData.data.buffer);

    // Constants & State
    const COURANT_NUMBER = 0.5;
    let running = true;
    let tick = 0;
    let frequency = 0.14;
    let simSpeed = 1;
    
    // Interaction State
    let drawing = false;
    let lastDrawPos = null;
    let drawMode = 1; // 1 = Wall, 2 = Source
    
    // Source Management
    let sources = [];
    
    // Initialize default source
    sources.push(Math.floor(height/2) * width + Math.floor(width/4));

    // --- Physics ---
    function updateMaxwell() {
        // H-fields
        for (let y = 0; y < height - 1; y++) {
            for (let x = 0; x < width - 1; x++) {
                const idx = y * width + x;
                Hx[idx] -= COURANT_NUMBER * (Ez[idx + width] - Ez[idx]);
                Hy[idx] += COURANT_NUMBER * (Ez[idx + 1] - Ez[idx]);
            }
        }

        // E-field
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                const idx = y * width + x;
                
                if (Material[idx] === 1) {
                    Ez[idx] = 0;
                    continue;
                }

                Ez[idx] += COURANT_NUMBER * ((Hy[idx] - Hy[idx - 1]) - (Hx[idx] - Hx[idx - width]));
            }
        }

        // Source Injection
        tick++;
        const val = Math.sin(tick * frequency);
        for(let i = 0; i < sources.length; i++) {
            Ez[sources[i]] += val;
        }
    }

    // --- Rendering ---
    function render() {
        const WALL_COLOR = 0xFF808080; // Grey

        for (let y = 0; y < height; y++) {
            const yOffset = y * width;
            for (let x = 0; x < width; x++) {
                const idx = yOffset + x;
                let color;

                if (Material[idx] === 1) {
                    color = WALL_COLOR;
                } else {
                    const field = Ez[idx];
                    let r = 0, g = 0, b = 0;
                    // Intensity scaling
                    const val = Math.min(Math.abs(field) * 200, 255);
                    
                    if (field > 0) {
                        g = val; b = val; r = val * 0.1;
                    } else {
                        r = val; g = val * 0.2;
                    }
                    color = (255 << 24) | (b << 16) | (g << 8) | r;
                }

                // Block fill
                const screenY = y * scale;
                const screenX = x * scale;
                const canvasW = canvas.width;

                for (let sy = 0; sy < scale; sy++) {
                    const rowStart = (screenY + sy) * canvasW + screenX;
                    for (let sx = 0; sx < scale; sx++) {
                        pixels[rowStart + sx] = color;
                    }
                }
            }
        }

        ctx.putImageData(imgData, 0, 0);

        // Draw Source Markers (White squares)
        ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
        for(let s of sources) {
            const sx = (s % width) * scale;
            const sy = Math.floor(s / width) * scale;
            ctx.fillRect(sx, sy, scale, scale);
        }
    }

    // --- Loop ---
    function loop() {
        if (running) {
            for(let i=0; i<simSpeed; i++) updateMaxwell();
            render();
        }
        requestAnimationFrame(loop);
    }

    // --- Interaction ---
    function getGridPos(evt) {
        const rect = canvas.getBoundingClientRect();
        const clientX = (evt.touches && evt.touches.length > 0) ? evt.touches[0].clientX : evt.clientX;
        const clientY = (evt.touches && evt.touches.length > 0) ? evt.touches[0].clientY : evt.clientY;
        const x = Math.floor((clientX - rect.left) / (rect.width / width));
        const y = Math.floor((clientY - rect.top) / (rect.height / height));
        return { x, y };
    }

    function setWall(x, y) {
        if (x >= 0 && x < width && y >= 0 && y < height) {
            const idx = y * width + x;
            Material[idx] = 1;
            if (x + 1 < width) Material[idx + 1] = 1;
            if (y + 1 < height) Material[idx + width] = 1;
        }
    }

    function drawLine(x0, y0, x1, y1) {
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        const sx = (x0 < x1) ? 1 : -1;
        const sy = (y0 < y1) ? 1 : -1;
        let err = dx - dy;
        while (true) {
            setWall(x0, y0);
            if (x0 === x1 && y0 === y1) break;
            const e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x0 += sx; }
            if (e2 < dx) { err += dx; y0 += sy; }
        }
    }

    function handleStart(evt) {
        drawing = true;
        const pos = getGridPos(evt);
        
        if (drawMode === 1) {
            // Wall
            lastDrawPos = pos;
            setWall(pos.x, pos.y);
        } else if (drawMode === 2) {
            // Source (Single click only)
            if (pos.x >= 0 && pos.x < width && pos.y >= 0 && pos.y < height) {
                const idx = pos.y * width + pos.x;
                if (!sources.includes(idx)) sources.push(idx);
            }
        }
        
        if(!running) render();
    }

    function handleMove(evt) {
        if (!drawing) return;
        
        // Only drag for walls
        if (drawMode === 1) {
            const pos = getGridPos(evt);
            if (lastDrawPos) {
                drawLine(lastDrawPos.x, lastDrawPos.y, pos.x, pos.y);
            } else {
                setWall(pos.x, pos.y);
            }
            lastDrawPos = pos;
            if(!running) render();
        }
    }

    function handleEnd() {
        drawing = false;
        lastDrawPos = null;
    }

    // Listeners
    canvas.addEventListener('mousedown', handleStart);
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(e); }, { passive: false });
    window.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); }, { passive: false });
    window.addEventListener('touchend', handleEnd);

    // Controls
    const btnPause = document.getElementById('btnPause');
    const btnModeWall = document.getElementById('btnModeWall');
    const btnModeSource = document.getElementById('btnModeSource');
    const statusText = document.getElementById('statusText');

    btnPause.addEventListener('click', () => {
        running = !running;
        btnPause.innerText = running ? "Pause" : "Resume";
        btnPause.className = running ? "success" : "secondary"; // Visual feedback
        if (running) loop();
    });

    // Mode Switching
    function setMode(mode) {
        drawMode = mode;
        if (mode === 1) {
            btnModeWall.className = 'active';
            btnModeSource.className = '';
            statusText.innerText = "Ez Field | Mode: Draw Walls (Drag)";
        } else {
            btnModeWall.className = '';
            btnModeSource.className = 'active';
            statusText.innerText = "Ez Field | Mode: Add Sources (Click)";
        }
    }

    btnModeWall.addEventListener('click', () => setMode(1));
    btnModeSource.addEventListener('click', () => setMode(2));

    document.getElementById('btnClear').addEventListener('click', () => {
        Material.fill(0);
        if(!running) render();
    });

    document.getElementById('btnClearSources').addEventListener('click', () => {
        sources = [];
        if(!running) render();
    });

    document.getElementById('btnReset').addEventListener('click', () => {
        // Reset Physics
        Ez.fill(0);
        Hx.fill(0);
        Hy.fill(0);
        tick = 0;
        
        // Reset Environment
        Material.fill(0);
        
        // Reset Sources to default
        sources = [Math.floor(height/2) * width + Math.floor(width/4)];
        
        if(!running) render();
    });

    document.getElementById('freq').addEventListener('input', (e) => {
        frequency = e.target.value * 0.02;
    });

    document.getElementById('speed').addEventListener('input', (e) => {
        simSpeed = parseInt(e.target.value);
    });

    // Start
    loop();

</script>
</body>
</html>
